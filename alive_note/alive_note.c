//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

/*struct _IO_FILE {
    int32_t e0;
};*/

// ------------------- Function Prototypes --------------------

void add_note(void);
int32_t check(char * str);
void del_note(void);
int32_t menu(void);
int32_t read_input(char * buf, int32_t nbyte);
int32_t read_int(void);
void show_note(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x804a060
struct _IO_FILE * g2 = NULL; // 0x804a064
int32_t g3 = 0; // 0x804a080

// ------------------------ Functions -------------------------

// Address range: 0x804868b - 0x80486e9
int32_t read_input(char * buf, int32_t nbyte) {
    int32_t v1 = read(0, buf, nbyte); // 0x804869c
    if (v1 <= 0) {
        // 0x80486ad
        puts("read error");
        exit(1);
        // UNREACHABLE
    }
    int32_t v2 = (int32_t)buf - 1 + v1; // 0x80486d0
    char * v3 = (char *)v2;
    unsigned char v4 = *v3; // 0x80486d2
    int32_t result = v4; // 0x80486e9_2
    if (v4 == 10) {
        // 0x80486d9
        *v3 = 0;
        result = v2;
        // branch -> 0x80486e7
    }
    // 0x80486e7
    return result;
}

// Address range: 0x80486ea - 0x8048758
int32_t read_int(void) {
    int32_t buf;
    if (read(0, (char *)&buf, 15) <= 0) {
        // 0x8048717
        puts("read error");
        exit(1);
        // UNREACHABLE
    }
    int32_t str_as_i = atoi((char *)&buf); // 0x8048738
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x8048752
        __stack_chk_fail();
        // branch -> 0x8048757
    }
    // 0x8048757
    return str_as_i;
}

// Address range: 0x8048759 - 0x80487c5
int32_t check(char * str) {
    char * v1 = str;
    if (strlen(str) == 0) {
        // 0x80487c4
        return 1;
    }
    int32_t v2 = 0;
    while (true) {
        // 0x8048768
        char * str2;
        if (*(char *)((int32_t)str + v2) != 32) {
            // 0x8048777
            int32_t v3;
            *(int32_t *)((int32_t)&v3 - 4) = 0x804877c;
            int32_t v4 = *(int32_t *)__ctype_b_loc(); // 0x804877c
            char v5 = *(char *)((int32_t)v1 + v2); // 0x8048786
            if (((int32_t)*(int16_t *)(2 * (int32_t)v5 + v4) & 8) != 0) {
                str2 = v1;
                goto lab_0x80487a4;
            }
            // 0x80487c4
            return 0;
        }
        str2 = str;
      lab_0x80487a4:;
        int32_t v6 = v2 + 1; // 0x80487a4
        if (strlen(str2) <= v6) {
            // break -> 0x80487c4
            break;
        }
        v2 = v6;
        str = str2;
        // continue -> 0x8048768
    }
    // 0x80487c4
    return 1;
}

// Address range: 0x80487c6 - 0x804889d
void add_note(void) {
    printf("Index :");
    int32_t v1 = read_int(); // 0x80487e7
    if (v1 >= 11) {
        // 0x80487f5
        puts("Out of bound !!");
        exit(0);
        // UNREACHABLE
    }
    // 0x804880f
    printf("Name :");
    int32_t str;
    read_input((char *)&str, 8);
    if (check((char *)&str) == 0) {
        // 0x804887d
        puts("It must be a alnum name !");
        exit(-1);
        // UNREACHABLE
    }
    char * v2 = strdup((char *)&str); // 0x804884a
    *(int32_t *)(4 * v1 + (int32_t)&g3) = (int32_t)v2;
    puts("Done !");
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x8048897
        __stack_chk_fail();
        // branch -> 0x804889c
    }
}

// Address range: 0x804889e - 0x8048902
void del_note(void) {
    // 0x804889e
    printf("Index :");
    int32_t v1 = read_int(); // 0x80488b4
    if (v1 >= 11) {
        // 0x80488c2
        puts("Out of bound !!");
        exit(0);
        // UNREACHABLE
    }
    int32_t * v2 = (int32_t *)(4 * v1 + (int32_t)&g3); // 0x80488df_0
    free((char *)*v2);
    *v2 = 0;
}

// Address range: 0x8048903 - 0x804896c
void show_note(void) {
    // 0x8048903
    printf("Index :");
    int32_t v1 = read_int(); // 0x8048919
    if (v1 >= 11) {
        // 0x8048927
        puts("Out of bound !!");
        exit(0);
        // UNREACHABLE
    }
    int32_t * v2 = (int32_t *)(4 * v1 + (int32_t)&g3); // 0x8048944_0
    if (*v2 != 0) {
        // 0x804894f
        printf("Name : %s\n", (char *)*v2);
        // branch -> 0x804896a
    }
}

// Address range: 0x804896d - 0x8048a05
int32_t menu(void) {
    // 0x804896d
    puts("-----------------------------------");
    puts("             AliveNote             ");
    puts("-----------------------------------");
    puts(" 1. Add a name                     ");
    puts(" 2. show a name on the note        ");
    puts(" 3. delete a name int the note     ");
    puts(" 4. Exit                           ");
    puts("-----------------------------------");
    return printf("Your choice :");
}

// Address range: 0x8048a06 - 0x8048a9f
int main(int argc, char ** argv) {
    // 0x8048a06
    //setvbuf(g2, NULL, 2, 0);
    //setvbuf((struct _IO_FILE *)g1, NULL, 2, 0);
    // branch -> 0x8048a3f
    while (true) {
        // 0x8048a3f
        menu();
        int32_t v1 = read_int(); // 0x8048a44
        int32_t v2 = v1 - 2; // 0x8048a49
        if (v2 == 0) {
            // 0x8048a6d
            show_note();
            // branch -> 0x8048a3f
            continue;
        } else {
            // 0x8048a4e
            if (v2 < 0 ^ (1 - v1 & v1) < 0) {
                // 0x8048a53
                if (v1 == 1) {
                    // 0x8048a66
                    add_note();
                    // branch -> 0x8048a3f
                    continue;
                } else {
                    // 0x8048a85
                    puts("Invalid choice");
                    // branch -> 0x8048a3f
                    continue;
                }
            } else {
                // 0x8048a5a
                switch (v1) {
                    case 3: {
                        // 0x8048a74
                        del_note();
                        // branch -> 0x8048a3f
                        continue;
                    }
                    case 4: {
                        // 0x8048a7b
                        exit(0);
                        // UNREACHABLE
                    }
                }
                // 0x8048a85
                puts("Invalid choice");
                // branch -> 0x8048a3f
                continue;
            }
        }
    }
}

// --------------- Dynamically Linked Functions ---------------

// const unsigned short int ** __ctype_b_loc(void);
// void __stack_chk_fail(void);
// int atoi(const char * nptr);
// void exit(int status);
// void free(void * ptr);
// int printf(const char * restrict format, ...);
// int puts(const char * s);
// ssize_t read(int fd, void * buf, size_t nbytes);
// int setvbuf(FILE * restrict stream, char * restrict buf, int modes, size_t n);
// char * strdup(const char * s);
// size_t strlen(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (5.4.0)
// Detected functions: 8
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-09-29 02:29:10
